{"pageProps":{"post":{"attributes":{"title":"Why Use a Permission Library?"},"html":"<p>We&#39;ve built our own ABAC system from scratch, which is great for understanding how permissions work. But in production, you might want to use a battle-tested library instead.</p>\n<h2>When to Use a Library</h2>\n<p>Building your own permission system makes sense when:</p>\n<ul>\n<li>Learning how permissions work (like this course!)</li>\n<li>You need maximum control over your permission logic</li>\n<li>Your permissions aren&#39;t too complex</li>\n</ul>\n<p>Using a library makes sense when:</p>\n<ul>\n<li>You want well-tested, production-ready code</li>\n<li>You need advanced features</li>\n<li>You want to follow established patterns</li>\n<li>Your team needs documentation and community support</li>\n</ul>\n<h2>Two Types of Permission Libraries</h2>\n<p>Permission libraries generally fall into two main categories based on how you define policies:</p>\n<h3>1. In-Code Libraries</h3>\n<p>These libraries define permissions using the same programming language as your application:</p>\n<pre><code class=\"hljs language-typescript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\">// Permissions defined in JavaScript/TypeScript</span>\n<span class=\"hljs-keyword\">const</span> ability = <span class=\"hljs-title function_\">defineAbility</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">can, cannot</span>) =&gt;</span> {\n  <span class=\"hljs-title function_\">can</span>(<span class=\"hljs-string\">&quot;read&quot;</span>, <span class=\"hljs-string\">&quot;Document&quot;</span>, { <span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">&quot;published&quot;</span> })\n  <span class=\"hljs-title function_\">can</span>(<span class=\"hljs-string\">&quot;update&quot;</span>, <span class=\"hljs-string\">&quot;Document&quot;</span>, { <span class=\"hljs-attr\">creatorId</span>: user.<span class=\"hljs-property\">id</span> })\n  <span class=\"hljs-title function_\">cannot</span>(<span class=\"hljs-string\">&quot;delete&quot;</span>, <span class=\"hljs-string\">&quot;Document&quot;</span>, { <span class=\"hljs-attr\">isLocked</span>: <span class=\"hljs-literal\">true</span> })\n})\n</code></pre><p><strong>Pros:</strong></p>\n<ul>\n<li>Full IDE support (autocomplete, type checking)</li>\n<li>Easy to debug (same language, same tools)</li>\n<li>No context switching between languages</li>\n<li>Can use application logic directly</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li>Policies are embedded in application code</li>\n<li>Harder to externalize or share policies</li>\n<li>Changes require redeploying the application (unless using a dynamic configuration system)</li>\n</ul>\n<p><strong>Popular in-code libraries:</strong></p>\n<ul>\n<li><strong>CASL</strong> (JavaScript/TypeScript)</li>\n<li><strong>Pundit</strong> (Ruby)</li>\n<li><strong>Cancan</strong> (Ruby)</li>\n</ul>\n<h3>2. DSL Libraries (Domain-Specific Language)</h3>\n<p>These libraries define permissions using a dedicated policy language:</p>\n<pre><code class=\"hljs language-ini\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\"># model.conf - Defines the permission structure</span>\n<span class=\"hljs-section\">[request_definition]</span>\n<span class=\"hljs-attr\">r</span> = sub, obj, act\n\n<span class=\"hljs-section\">[policy_definition]</span>\n<span class=\"hljs-attr\">p</span> = sub, obj, act\n\n<span class=\"hljs-section\">[matchers]</span>\n<span class=\"hljs-attr\">m</span> = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act\n</code></pre><pre><code class=\"hljs language-csv\"><button class=\"copy-btn\">Copy</button># policy.csv - The actual rules\np, admin, document, read\np, admin, document, update\np, admin, document, delete\np, editor, document, read\np, editor, document, update\n</code></pre><p><strong>Pros:</strong></p>\n<ul>\n<li>Policies are separate from application code</li>\n<li>Can update policies without redeploying</li>\n<li>Same policies work across different services</li>\n<li>Easier to audit (policies in one place)</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li>Must learn a new language</li>\n<li>Limited IDE support (usually)</li>\n<li>Debugging across language boundary is harder</li>\n<li>Extra infrastructure to manage policy files</li>\n</ul>\n<p><strong>Popular DSL libraries:</strong></p>\n<ul>\n<li><strong>Casbin</strong> - Supports multiple languages</li>\n<li><strong>Open Policy Agent (OPA)</strong> - Uses Rego language</li>\n<li><strong>Cedar</strong> - AWS&#39;s policy language</li>\n</ul>\n<h2>Our Example Libraries</h2>\n<p>You may have already noticed our ABAC system is an in code system and is actually heavily inspired by CASL which we will be implementing in this course.</p>\n<h3>CASL (In-Code)</h3>\n<p>CASL is a popular JavaScript/TypeScript library for handling permissions:</p>\n<pre><code class=\"hljs language-typescript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AbilityBuilder</span>, createMongoAbility } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@casl/ability&quot;</span>\n\n<span class=\"hljs-keyword\">const</span> { can, build } = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AbilityBuilder</span>(createMongoAbility)\n\n<span class=\"hljs-title function_\">can</span>(<span class=\"hljs-string\">&quot;read&quot;</span>, <span class=\"hljs-string\">&quot;Document&quot;</span>, { <span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">&quot;published&quot;</span> })\n<span class=\"hljs-title function_\">can</span>(<span class=\"hljs-string\">&quot;update&quot;</span>, <span class=\"hljs-string\">&quot;Document&quot;</span>, { <span class=\"hljs-attr\">creatorId</span>: user.<span class=\"hljs-property\">id</span>, <span class=\"hljs-attr\">isLocked</span>: <span class=\"hljs-literal\">false</span> })\n\n<span class=\"hljs-keyword\">const</span> ability = <span class=\"hljs-title function_\">build</span>()\n\n<span class=\"hljs-comment\">// Check permissions</span>\nability.<span class=\"hljs-title function_\">can</span>(<span class=\"hljs-string\">&quot;read&quot;</span>, <span class=\"hljs-title function_\">subject</span>(<span class=\"hljs-string\">&quot;Document&quot;</span>, <span class=\"hljs-variable language_\">document</span>))\nability.<span class=\"hljs-title function_\">can</span>(<span class=\"hljs-string\">&quot;update&quot;</span>, <span class=\"hljs-title function_\">subject</span>(<span class=\"hljs-string\">&quot;Document&quot;</span>, <span class=\"hljs-variable language_\">document</span>))\n</code></pre><h3>Casbin (DSL)</h3>\n<p>Casbin uses a model/policy separation where you define:</p>\n<ol>\n<li><strong>Model file</strong> - The structure of your permissions</li>\n<li><strong>Policy file</strong> - The actual rules</li>\n</ol>\n<pre><code class=\"hljs language-ini\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-comment\"># model.conf - Defines the structure</span>\n<span class=\"hljs-section\">[request_definition]</span>\n<span class=\"hljs-attr\">r</span> = sub, obj, act\n\n<span class=\"hljs-section\">[policy_definition]</span>\n<span class=\"hljs-attr\">p</span> = sub, obj, act\n\n<span class=\"hljs-section\">[policy_effect]</span>\n<span class=\"hljs-attr\">e</span> = some(where (p.eft == allow))\n\n<span class=\"hljs-section\">[matchers]</span>\n<span class=\"hljs-attr\">m</span> = r.sub == p.sub &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act\n</code></pre><pre><code class=\"hljs language-csv\"><button class=\"copy-btn\">Copy</button># policy.csv - The actual rules\np, admin, document, read\np, admin, document, create\np, admin, document, update\np, admin, document, delete\np, editor, document, read\np, editor, document, update\n</code></pre><p>Casbin&#39;s approach is much harder to parse until you learn the language around it, but it is more flexible since you can use it across multiple languages and services.</p>\n<h2>Which Should You Choose?</h2>\n<table>\n<thead>\n<tr>\n<th>Factor</th>\n<th>In-Code (CASL)</th>\n<th>DSL (Casbin)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Learning curve</strong></td>\n<td>Easy if you know JS</td>\n<td>Must learn new syntax</td>\n</tr>\n<tr>\n<td><strong>Type safety</strong></td>\n<td>Full TypeScript support</td>\n<td>Limited</td>\n</tr>\n<tr>\n<td><strong>Policy updates</strong></td>\n<td>May require a redeploy</td>\n<td>Can update dynamically</td>\n</tr>\n<tr>\n<td><strong>Multi-service</strong></td>\n<td>Harder to share</td>\n<td>Built for this</td>\n</tr>\n<tr>\n<td><strong>Debugging</strong></td>\n<td>Same tools</td>\n<td>Harder</td>\n</tr>\n</tbody></table>\n<p><strong>Choose in-code (CASL) when:</strong></p>\n<ul>\n<li>Your app is monolithic or has few services that use other languages</li>\n<li>You want maximum type safety</li>\n<li>Your team is JavaScript/TypeScript focused</li>\n</ul>\n<p><strong>Choose DSL (Casbin) when:</strong></p>\n<ul>\n<li>You have multiple services sharing policies across different languages</li>\n<li>You need to update policies without deploying</li>\n<li>You have a security team managing policies</li>\n</ul>\n<h2>What&#39;s Next</h2>\n<p>In the next lesson, we&#39;ll dive deeper into how to implement CASL in our existing application.</p>\n","markdown":"\nWe've built our own ABAC system from scratch, which is great for understanding how permissions work. But in production, you might want to use a battle-tested library instead.\n\n## When to Use a Library\n\nBuilding your own permission system makes sense when:\n\n- Learning how permissions work (like this course!)\n- You need maximum control over your permission logic\n- Your permissions aren't too complex\n\nUsing a library makes sense when:\n\n- You want well-tested, production-ready code\n- You need advanced features\n- You want to follow established patterns\n- Your team needs documentation and community support\n\n## Two Types of Permission Libraries\n\nPermission libraries generally fall into two main categories based on how you define policies:\n\n### 1. In-Code Libraries\n\nThese libraries define permissions using the same programming language as your application:\n\n```typescript\n// Permissions defined in JavaScript/TypeScript\nconst ability = defineAbility((can, cannot) => {\n  can(\"read\", \"Document\", { status: \"published\" })\n  can(\"update\", \"Document\", { creatorId: user.id })\n  cannot(\"delete\", \"Document\", { isLocked: true })\n})\n```\n\n**Pros:**\n\n- Full IDE support (autocomplete, type checking)\n- Easy to debug (same language, same tools)\n- No context switching between languages\n- Can use application logic directly\n\n**Cons:**\n\n- Policies are embedded in application code\n- Harder to externalize or share policies\n- Changes require redeploying the application (unless using a dynamic configuration system)\n\n**Popular in-code libraries:**\n\n- **CASL** (JavaScript/TypeScript)\n- **Pundit** (Ruby)\n- **Cancan** (Ruby)\n\n### 2. DSL Libraries (Domain-Specific Language)\n\nThese libraries define permissions using a dedicated policy language:\n\n```ini\n# model.conf - Defines the permission structure\n[request_definition]\nr = sub, obj, act\n\n[policy_definition]\np = sub, obj, act\n\n[matchers]\nm = r.sub == p.sub && r.obj == p.obj && r.act == p.act\n```\n\n```csv\n# policy.csv - The actual rules\np, admin, document, read\np, admin, document, update\np, admin, document, delete\np, editor, document, read\np, editor, document, update\n```\n\n**Pros:**\n\n- Policies are separate from application code\n- Can update policies without redeploying\n- Same policies work across different services\n- Easier to audit (policies in one place)\n\n**Cons:**\n\n- Must learn a new language\n- Limited IDE support (usually)\n- Debugging across language boundary is harder\n- Extra infrastructure to manage policy files\n\n**Popular DSL libraries:**\n\n- **Casbin** - Supports multiple languages\n- **Open Policy Agent (OPA)** - Uses Rego language\n- **Cedar** - AWS's policy language\n\n## Our Example Libraries\n\nYou may have already noticed our ABAC system is an in code system and is actually heavily inspired by CASL which we will be implementing in this course.\n\n### CASL (In-Code)\n\nCASL is a popular JavaScript/TypeScript library for handling permissions:\n\n```typescript\nimport { AbilityBuilder, createMongoAbility } from \"@casl/ability\"\n\nconst { can, build } = new AbilityBuilder(createMongoAbility)\n\ncan(\"read\", \"Document\", { status: \"published\" })\ncan(\"update\", \"Document\", { creatorId: user.id, isLocked: false })\n\nconst ability = build()\n\n// Check permissions\nability.can(\"read\", subject(\"Document\", document))\nability.can(\"update\", subject(\"Document\", document))\n```\n\n### Casbin (DSL)\n\nCasbin uses a model/policy separation where you define:\n\n1. **Model file** - The structure of your permissions\n2. **Policy file** - The actual rules\n\n```ini\n# model.conf - Defines the structure\n[request_definition]\nr = sub, obj, act\n\n[policy_definition]\np = sub, obj, act\n\n[policy_effect]\ne = some(where (p.eft == allow))\n\n[matchers]\nm = r.sub == p.sub && r.obj == p.obj && r.act == p.act\n```\n\n```csv\n# policy.csv - The actual rules\np, admin, document, read\np, admin, document, create\np, admin, document, update\np, admin, document, delete\np, editor, document, read\np, editor, document, update\n```\n\nCasbin's approach is much harder to parse until you learn the language around it, but it is more flexible since you can use it across multiple languages and services.\n\n## Which Should You Choose?\n\n| Factor             | In-Code (CASL)          | DSL (Casbin)           |\n| ------------------ | ----------------------- | ---------------------- |\n| **Learning curve** | Easy if you know JS     | Must learn new syntax  |\n| **Type safety**    | Full TypeScript support | Limited                |\n| **Policy updates** | May require a redeploy  | Can update dynamically |\n| **Multi-service**  | Harder to share         | Built for this         |\n| **Debugging**      | Same tools              | Harder                 |\n\n**Choose in-code (CASL) when:**\n\n- Your app is monolithic or has few services that use other languages\n- You want maximum type safety\n- Your team is JavaScript/TypeScript focused\n\n**Choose DSL (Casbin) when:**\n\n- You have multiple services sharing policies across different languages\n- You need to update policies without deploying\n- You have a security team managing policies\n\n## What's Next\n\nIn the next lesson, we'll dive deeper into how to implement CASL in our existing application.\n","slug":"why-use-a-library","title":"Why Use a Permission Library?","section":"Permission Libraries","icon":"cubes","filePath":"/home/runner/work/fem-permission-systems-that-scale/fem-permission-systems-that-scale/lessons/05-permission-libraries/A-why-use-a-library.md","nextSlug":"/fem-permission-systems-that-scale/lessons/permission-libraries/upgrading-to-casl","prevSlug":"/fem-permission-systems-that-scale/lessons/abac/clean-architecture-services"}},"__N_SSG":true}