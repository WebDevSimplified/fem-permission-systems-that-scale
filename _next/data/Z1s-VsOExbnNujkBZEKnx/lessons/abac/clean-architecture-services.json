{"pageProps":{"post":{"attributes":{"title":"Clean Architecture: The Services Layer"},"html":"<p>Our ABAC system works, but authorization logic is scattered everywhere. Let&#39;s fix that by introducing a <strong>services layer</strong> that centralizes all permission checks.</p>\n<h2>The Problem</h2>\n<p>Currently, auth checks live in multiple places:</p>\n<pre><code class=\"hljs language-text\"><button class=\"copy-btn\">Copy</button>üìÅ src/\n‚îú‚îÄ‚îÄ üìÅ actions/\n‚îÇ   ‚îú‚îÄ‚îÄ documents.ts    ‚Üê Auth checks here\n‚îÇ   ‚îî‚îÄ‚îÄ projects.ts     ‚Üê Auth checks here\n‚îú‚îÄ‚îÄ üìÅ dal/\n‚îÇ   ‚îî‚îÄ‚îÄ documents.ts    ‚Üê And here\n‚îî‚îÄ‚îÄ üìÅ app/\n    ‚îî‚îÄ‚îÄ (pages)/\n        ‚îú‚îÄ‚îÄ documents/  ‚Üê And here too!\n        ‚îî‚îÄ‚îÄ projects/\n</code></pre><p>This creates problems:</p>\n<ol>\n<li><strong>Duplication</strong> - Same checks written multiple ways</li>\n<li><strong>Inconsistency</strong> - Easy to forget a check somewhere</li>\n<li><strong>Difficult testing</strong> - Auth logic tied to framework code</li>\n<li><strong>Performance</strong> - Potentially extra database queries</li>\n</ol>\n<h2>The Solution: Services Layer</h2>\n<p>We&#39;ll create a dedicated layer for business logic which includes authorization checks:</p>\n<pre><code class=\"hljs language-text\"><button class=\"copy-btn\">Copy</button>üìÅ src/\n‚îú‚îÄ‚îÄ üìÅ services/        ‚Üê NEW: All auth lives here\n‚îÇ   ‚îú‚îÄ‚îÄ documents.ts\n‚îÇ   ‚îî‚îÄ‚îÄ projects.ts\n‚îú‚îÄ‚îÄ üìÅ actions/         ‚Üê Just validates &amp; calls services\n‚îú‚îÄ‚îÄ üìÅ dal/             ‚Üê Just database access\n‚îî‚îÄ‚îÄ üìÅ app/             ‚Üê Just UI concerns\n</code></pre><h2>A Basic Service</h2>\n<p>The key to our service layer is that each function in this layer should take into account all authorization checks and only return data the user has access to. This centralizes authorization logic and ensures consistency across the application.</p>\n<pre><code class=\"hljs language-typescript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createDocumentService</span>(<span class=\"hljs-params\">\n  <span class=\"hljs-attr\">projectId</span>: <span class=\"hljs-built_in\">string</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">DocumentFormValues</span>,\n</span>) {\n  <span class=\"hljs-comment\">// Step 1: Authentication - who is making this request?</span>\n  <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getCurrentUser</span>()\n  <span class=\"hljs-keyword\">if</span> (user == <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;Unauthenticated&quot;</span>)\n\n  <span class=\"hljs-comment\">// Step 2: Authorization - can they perform this action?</span>\n  <span class=\"hljs-keyword\">const</span> permissions = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getUserPermissions</span>()\n  <span class=\"hljs-keyword\">if</span> (!permissions.<span class=\"hljs-title function_\">can</span>(<span class=\"hljs-string\">&quot;document&quot;</span>, <span class=\"hljs-string\">&quot;create&quot;</span>)) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AuthorizationError</span>()\n\n  <span class=\"hljs-comment\">// Step 3: Field filtering - only allow permitted fields</span>\n  <span class=\"hljs-keyword\">const</span> restrictedData = permissions.<span class=\"hljs-title function_\">pickPermittedFields</span>(\n    <span class=\"hljs-string\">&quot;document&quot;</span>,\n    <span class=\"hljs-string\">&quot;create&quot;</span>,\n    data,\n  )\n\n  <span class=\"hljs-comment\">// Step 4: Validation - is the data valid?</span>\n  <span class=\"hljs-keyword\">const</span> result = documentSchema.<span class=\"hljs-title function_\">safeParse</span>(restrictedData)\n  <span class=\"hljs-keyword\">if</span> (!result.<span class=\"hljs-property\">success</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;Invalid data&quot;</span>)\n\n  <span class=\"hljs-comment\">// Step 5: Execute - perform the actual operation</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">createDocument</span>({\n    ...result.<span class=\"hljs-property\">data</span>,\n    <span class=\"hljs-attr\">creatorId</span>: user.<span class=\"hljs-property\">id</span>,\n    <span class=\"hljs-attr\">lastEditedById</span>: user.<span class=\"hljs-property\">id</span>,\n    projectId,\n  })\n}\n</code></pre><p>In the above example we are checking the user&#39;s permission to create a document and ensuring only the fields they are allowed to modify are used for the creation. This centralizes authorization logic and prevents unauthorized field modifications.</p>\n<p>Our action is now a simple wrapper that calls this service function and handles any errors or responses appropriately:</p>\n<pre><code class=\"hljs language-typescript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createDocumentAction</span>(<span class=\"hljs-params\">\n  <span class=\"hljs-attr\">projectId</span>: <span class=\"hljs-built_in\">string</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">DocumentFormValues</span>,\n</span>) {\n  <span class=\"hljs-keyword\">const</span> [error, <span class=\"hljs-variable language_\">document</span>] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">tryFn</span>(<span class=\"hljs-function\">() =&gt;</span>\n    <span class=\"hljs-title function_\">createDocumentService</span>(projectId, data),\n  )\n\n  <span class=\"hljs-keyword\">if</span> (error) <span class=\"hljs-keyword\">return</span> error\n\n  <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">`/projects/<span class=\"hljs-subst\">${projectId}</span>/documents/<span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">document</span>.id}</span>`</span>)\n}\n</code></pre><p>Notice what&#39;s <strong>not</strong> in the action:</p>\n<ul>\n<li>No <code>if (!canUpdate)</code> checks</li>\n<li>No manual field filtering</li>\n<li>No permission imports</li>\n</ul>\n<p>All that complexity lives in the service.</p>\n<h2>Refactoring Page Components</h2>\n<p>Pages delegate to services and no longer include any direct permission checks:</p>\n<pre><code class=\"hljs language-typescript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ProjectDocumentsPage</span>(<span class=\"hljs-params\">{\n  params,\n}: <span class=\"hljs-title class_\">PageProps</span>&lt;<span class=\"hljs-string\">&quot;/projects/[projectId]&quot;</span>&gt;</span>) {\n  <span class=\"hljs-keyword\">const</span> { projectId } = <span class=\"hljs-keyword\">await</span> params\n\n  <span class=\"hljs-comment\">// Returns null if not found or not authorized</span>\n  <span class=\"hljs-keyword\">const</span> project = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getProjectByIdService</span>(projectId)\n  <span class=\"hljs-keyword\">if</span> (project == <span class=\"hljs-literal\">null</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">notFound</span>()\n\n  <span class=\"hljs-comment\">// Only fetch documents the user is authorized to see</span>\n  <span class=\"hljs-keyword\">const</span> documents = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getProjectDocumentsService</span>(projectId)\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-comment\">// UI</span>\n  )\n}\n</code></pre><h2>Architecture Benefits</h2>\n<h3>1. Single Responsibility</h3>\n<table>\n<thead>\n<tr>\n<th>Layer</th>\n<th>Responsibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Pages</strong></td>\n<td>Routing, layout, calling services</td>\n</tr>\n<tr>\n<td><strong>Actions</strong></td>\n<td>Form handling, validation, revalidation</td>\n</tr>\n<tr>\n<td><strong>Services</strong></td>\n<td>Business logic, authorization</td>\n</tr>\n<tr>\n<td><strong>DAL</strong></td>\n<td>Pure database operations</td>\n</tr>\n</tbody></table>\n<p>This is very important since now you can use the data access layer to get data without having to worry about authorization logic or user context since many times in your application you may want to get all records regardless of the current user&#39;s permissions for specific business logic.</p>\n<h3>2. Testability</h3>\n<p>Since our data access layer, actions, and ui are no longer tied to the user or permissions we can easily test those layers in isolation. It is also easier to test our authorization logic since it all lives in one place.</p>\n<h3>3. Security by Default</h3>\n<p>As long as all calls go through the service layer it is impossible to accidentally bypass authorization checks or incorrectly code an authorization check since it is all handled automatically by the services layer.</p>\n<h3>4. Efficient Queries</h3>\n<p>By converting our auth permissions to a database query we are able to leverage the database&#39;s query engine to efficiently filter results based on the user&#39;s permissions, rather than fetching all data and filtering in application code.</p>\n<h2>Converting Permissions to Database Queries</h2>\n<p>The key insight is that ABAC conditions can become <code>WHERE</code> clauses:</p>\n<p><img src=\"/fem-permission-systems-that-scale/images/04-abac/abac-to-sql.svg\" alt=\"ABAC to SQL\"></p>\n<p>This can get complicated when dealing with multiple conditions and various combinations of permissions, but once you get the base layer down adding new conditions is pretty simple.</p>\n<p>This is powerful because:</p>\n<ul>\n<li>We only fetch data the user can see</li>\n<li>The database does the filtering (efficient!)</li>\n<li>No chance of data leaks from forgetting a filter</li>\n</ul>\n<h2>Live Coding Exercise</h2>\n<p>We&#39;ll refactor the codebase to:</p>\n<ol>\n<li>Create <code>src/services/documents.ts</code> and <code>src/services/projects.ts</code></li>\n<li>Implement <code>toDrizzleWhere()</code> for automatic query generation</li>\n<li>Refactor actions to use services</li>\n<li>Update page components to use services</li>\n<li>Remove auth code from actions and DAL</li>\n</ol>\n<h2>Branch Checkpoint</h2>\n<p>After completing this lesson, your code should match:</p>\n<pre><code class=\"hljs language-bash\"><button class=\"copy-btn\">Copy</button>git checkout 6-abac-advanced\n</code></pre><h2>Summary</h2>\n<p>The services layer pattern:</p>\n<ul>\n<li><strong>Centralizes</strong> all authorization in one place</li>\n<li><strong>Converts</strong> ABAC conditions to database queries</li>\n<li><strong>Simplifies</strong> actions and components</li>\n<li><strong>Enables</strong> easy testing of permissions</li>\n<li><strong>Prevents</strong> data leaks by filtering at the query level</li>\n</ul>\n<p>Our ABAC implementation is now:</p>\n<ul>\n<li>‚úÖ Type-safe</li>\n<li>‚úÖ Field-level permissions</li>\n<li>‚úÖ Environment-aware (time-based rules)</li>\n<li>‚úÖ Clean architecture</li>\n<li>‚úÖ Database-efficient</li>\n</ul>\n","markdown":"\nOur ABAC system works, but authorization logic is scattered everywhere. Let's fix that by introducing a **services layer** that centralizes all permission checks.\n\n## The Problem\n\nCurrently, auth checks live in multiple places:\n\n```text\nüìÅ src/\n‚îú‚îÄ‚îÄ üìÅ actions/\n‚îÇ   ‚îú‚îÄ‚îÄ documents.ts    ‚Üê Auth checks here\n‚îÇ   ‚îî‚îÄ‚îÄ projects.ts     ‚Üê Auth checks here\n‚îú‚îÄ‚îÄ üìÅ dal/\n‚îÇ   ‚îî‚îÄ‚îÄ documents.ts    ‚Üê And here\n‚îî‚îÄ‚îÄ üìÅ app/\n    ‚îî‚îÄ‚îÄ (pages)/\n        ‚îú‚îÄ‚îÄ documents/  ‚Üê And here too!\n        ‚îî‚îÄ‚îÄ projects/\n```\n\nThis creates problems:\n\n1. **Duplication** - Same checks written multiple ways\n2. **Inconsistency** - Easy to forget a check somewhere\n3. **Difficult testing** - Auth logic tied to framework code\n4. **Performance** - Potentially extra database queries\n\n## The Solution: Services Layer\n\nWe'll create a dedicated layer for business logic which includes authorization checks:\n\n```text\nüìÅ src/\n‚îú‚îÄ‚îÄ üìÅ services/        ‚Üê NEW: All auth lives here\n‚îÇ   ‚îú‚îÄ‚îÄ documents.ts\n‚îÇ   ‚îî‚îÄ‚îÄ projects.ts\n‚îú‚îÄ‚îÄ üìÅ actions/         ‚Üê Just validates & calls services\n‚îú‚îÄ‚îÄ üìÅ dal/             ‚Üê Just database access\n‚îî‚îÄ‚îÄ üìÅ app/             ‚Üê Just UI concerns\n```\n\n## A Basic Service\n\nThe key to our service layer is that each function in this layer should take into account all authorization checks and only return data the user has access to. This centralizes authorization logic and ensures consistency across the application.\n\n```typescript\nexport async function createDocumentService(\n  projectId: string,\n  data: DocumentFormValues,\n) {\n  // Step 1: Authentication - who is making this request?\n  const user = await getCurrentUser()\n  if (user == null) throw new Error(\"Unauthenticated\")\n\n  // Step 2: Authorization - can they perform this action?\n  const permissions = await getUserPermissions()\n  if (!permissions.can(\"document\", \"create\")) throw new AuthorizationError()\n\n  // Step 3: Field filtering - only allow permitted fields\n  const restrictedData = permissions.pickPermittedFields(\n    \"document\",\n    \"create\",\n    data,\n  )\n\n  // Step 4: Validation - is the data valid?\n  const result = documentSchema.safeParse(restrictedData)\n  if (!result.success) throw new Error(\"Invalid data\")\n\n  // Step 5: Execute - perform the actual operation\n  return await createDocument({\n    ...result.data,\n    creatorId: user.id,\n    lastEditedById: user.id,\n    projectId,\n  })\n}\n```\n\nIn the above example we are checking the user's permission to create a document and ensuring only the fields they are allowed to modify are used for the creation. This centralizes authorization logic and prevents unauthorized field modifications.\n\nOur action is now a simple wrapper that calls this service function and handles any errors or responses appropriately:\n\n```typescript\nexport async function createDocumentAction(\n  projectId: string,\n  data: DocumentFormValues,\n) {\n  const [error, document] = await tryFn(() =>\n    createDocumentService(projectId, data),\n  )\n\n  if (error) return error\n\n  redirect(`/projects/${projectId}/documents/${document.id}`)\n}\n```\n\nNotice what's **not** in the action:\n\n- No `if (!canUpdate)` checks\n- No manual field filtering\n- No permission imports\n\nAll that complexity lives in the service.\n\n## Refactoring Page Components\n\nPages delegate to services and no longer include any direct permission checks:\n\n```typescript\nexport default async function ProjectDocumentsPage({\n  params,\n}: PageProps<\"/projects/[projectId]\">) {\n  const { projectId } = await params\n\n  // Returns null if not found or not authorized\n  const project = await getProjectByIdService(projectId)\n  if (project == null) return notFound()\n\n  // Only fetch documents the user is authorized to see\n  const documents = await getProjectDocumentsService(projectId)\n\n  return (\n    // UI\n  )\n}\n```\n\n## Architecture Benefits\n\n### 1. Single Responsibility\n\n| Layer        | Responsibility                          |\n| ------------ | --------------------------------------- |\n| **Pages**    | Routing, layout, calling services       |\n| **Actions**  | Form handling, validation, revalidation |\n| **Services** | Business logic, authorization           |\n| **DAL**      | Pure database operations                |\n\nThis is very important since now you can use the data access layer to get data without having to worry about authorization logic or user context since many times in your application you may want to get all records regardless of the current user's permissions for specific business logic.\n\n### 2. Testability\n\nSince our data access layer, actions, and ui are no longer tied to the user or permissions we can easily test those layers in isolation. It is also easier to test our authorization logic since it all lives in one place.\n\n### 3. Security by Default\n\nAs long as all calls go through the service layer it is impossible to accidentally bypass authorization checks or incorrectly code an authorization check since it is all handled automatically by the services layer.\n\n### 4. Efficient Queries\n\nBy converting our auth permissions to a database query we are able to leverage the database's query engine to efficiently filter results based on the user's permissions, rather than fetching all data and filtering in application code.\n\n## Converting Permissions to Database Queries\n\nThe key insight is that ABAC conditions can become `WHERE` clauses:\n\n![ABAC to SQL](/fem-permission-systems-that-scale/images/04-abac/abac-to-sql.svg)\n\nThis can get complicated when dealing with multiple conditions and various combinations of permissions, but once you get the base layer down adding new conditions is pretty simple.\n\nThis is powerful because:\n\n- We only fetch data the user can see\n- The database does the filtering (efficient!)\n- No chance of data leaks from forgetting a filter\n\n## Live Coding Exercise\n\nWe'll refactor the codebase to:\n\n1. Create `src/services/documents.ts` and `src/services/projects.ts`\n2. Implement `toDrizzleWhere()` for automatic query generation\n3. Refactor actions to use services\n4. Update page components to use services\n5. Remove auth code from actions and DAL\n\n## Branch Checkpoint\n\nAfter completing this lesson, your code should match:\n\n```bash\ngit checkout 6-abac-advanced\n```\n\n## Summary\n\nThe services layer pattern:\n\n- **Centralizes** all authorization in one place\n- **Converts** ABAC conditions to database queries\n- **Simplifies** actions and components\n- **Enables** easy testing of permissions\n- **Prevents** data leaks by filtering at the query level\n\nOur ABAC implementation is now:\n\n- ‚úÖ Type-safe\n- ‚úÖ Field-level permissions\n- ‚úÖ Environment-aware (time-based rules)\n- ‚úÖ Clean architecture\n- ‚úÖ Database-efficient\n","slug":"clean-architecture-services","title":"Clean Architecture: The Services Layer","section":"Attribute-Based Access Control (ABAC)","icon":"cog","filePath":"/home/runner/work/fem-permission-systems-that-scale/fem-permission-systems-that-scale/lessons/04-abac/D-clean-architecture-services.md","nextSlug":"/fem-permission-systems-that-scale/lessons/permission-libraries/why-use-a-library","prevSlug":"/fem-permission-systems-that-scale/lessons/abac/advanced-abac-features"}},"__N_SSG":true}