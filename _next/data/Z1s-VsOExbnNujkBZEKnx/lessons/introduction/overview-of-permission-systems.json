{"pageProps":{"post":{"attributes":{"title":"Overview of Permission Systems","description":"A high-level introduction to RBAC, ABAC, and ReBAC — the three main approaches to authorization — and when to use each one."},"html":"<h1>Overview of Permission Systems</h1>\n<p>There are three main approaches to implementing authorization, each with different trade-offs between simplicity and flexibility.</p>\n<p><img src=\"/fem-permission-systems-that-scale/images/01-introduction/permission-systems-comparison.svg\" alt=\"Permission Systems Comparison\"></p>\n<h2>Role-Based Access Control (RBAC)</h2>\n<p><strong>RBAC</strong> assigns permissions based on a user&#39;s role. It&#39;s the most common and simplest approach.</p>\n<h3>How It Works</h3>\n<ol>\n<li>Define <strong>roles</strong> (admin, editor, viewer)</li>\n<li>Assign <strong>permissions</strong> to each role (can create, can edit, can delete)</li>\n<li>Assign <strong>roles</strong> to users</li>\n<li>Check: &quot;Does this user&#39;s role have this permission?&quot;</li>\n</ol>\n<h3>Example</h3>\n<table>\n<thead>\n<tr>\n<th>Role</th>\n<th>View</th>\n<th>Create</th>\n<th>Edit</th>\n<th>Delete</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Viewer</td>\n<td>✅</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Editor</td>\n<td>✅</td>\n<td>❌</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Author</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n<td>❌</td>\n</tr>\n<tr>\n<td>Admin</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n</tbody></table>\n<h3>Best For</h3>\n<ul>\n<li>Applications with clear, hierarchical user types</li>\n<li>When permissions don&#39;t depend on the specific resource</li>\n<li>Simple permission requirements that change infrequently</li>\n</ul>\n<h3>Limitations</h3>\n<ul>\n<li>Can&#39;t express &quot;editors can only edit documents in their department&quot;</li>\n<li>Role explosion when you need fine-grained control</li>\n<li>Difficult to handle resource-specific permissions</li>\n</ul>\n<h2>Attribute-Based Access Control (ABAC)</h2>\n<p><strong>ABAC</strong> makes decisions based on attributes of the user, resource, and environment.</p>\n<h3>How It Works</h3>\n<ol>\n<li>Define <strong>attributes</strong> on users (department, role, clearance level)</li>\n<li>Define <strong>attributes</strong> on resources (status, owner, department)</li>\n<li>Write <strong>policies</strong> that combine attributes with logic</li>\n<li>Check: &quot;Do the attributes satisfy this policy?&quot;</li>\n</ol>\n<h3>Example Policy</h3>\n<pre><code class=\"hljs language-text\"><button class=\"copy-btn\">Copy</button>ALLOW edit document IF:\n  - user.role IN [editor, author, admin]\n  - AND document.status != &quot;archived&quot;\n  - AND (document.department == user.department OR user.role == &quot;admin&quot;)\n  - AND document.isLocked == false\n</code></pre><h3>Best For</h3>\n<ul>\n<li>Complex, dynamic permission requirements</li>\n<li>Multi-tenant applications</li>\n<li>When permissions depend on resource properties</li>\n<li>Fine-grained, field-level access control</li>\n</ul>\n<h3>Limitations</h3>\n<ul>\n<li>More complex to implement and understand</li>\n<li>Policies can become hard to audit</li>\n<li>Performance considerations with many attribute checks</li>\n</ul>\n<h2>Relationship-Based Access Control (ReBAC)</h2>\n<p><strong>ReBAC</strong> determines access based on the relationships between users and resources.</p>\n<h3>How It Works</h3>\n<ol>\n<li>Define <strong>relationship types</strong> (owner, member, viewer)</li>\n<li>Create <strong>relationships</strong> between users and resources</li>\n<li>Define <strong>permission rules</strong> based on relationships</li>\n<li>Check: &quot;Does this user have a relationship that grants this permission?&quot;</li>\n</ol>\n<h3>Example</h3>\n<pre><code class=\"hljs language-text\"><button class=\"copy-btn\">Copy</button>User &quot;alice&quot; --[owner]--&gt; Project &quot;docs&quot;\nProject &quot;docs&quot; --[contains]--&gt; Document &quot;readme&quot;\n\nRule: owner of project can edit documents in that project\nResult: Alice can edit &quot;readme&quot;\n</code></pre><h3>Best For</h3>\n<ul>\n<li>Social applications (who can see whose posts?)</li>\n<li>Collaborative tools (shared folders, team workspaces)</li>\n<li>When permissions flow through object hierarchies</li>\n<li>Google Drive-style sharing models</li>\n</ul>\n<h3>Limitations</h3>\n<ul>\n<li>Requires a relationship graph (often a separate database)</li>\n<li>Can be overkill for simpler permission models</li>\n<li>More infrastructure complexity</li>\n</ul>\n<h2>Policy Engines</h2>\n<p>Every authorization needs a policy engine that takes in all the parameters of the access request (user, resource, action, context) and evaluates them against the defined policies to make an allow/deny decision. These engines usually take one of two forms.</p>\n<h3>Domain Specific Language (DSL)</h3>\n<p>A domain-specific language is a specialized language designed to express authorization policies. It allows you to write rules in a concise, human-readable format that the policy engine can interpret.</p>\n<h4>Example</h4>\n<pre><code class=\"hljs language-text\"><button class=\"copy-btn\">Copy</button>allow(user, action, resource) if\n  user.role == &quot;admin&quot; or\n  (user.role == &quot;editor&quot; and resource.department == user.department)\n</code></pre><h3>In-Language Engine</h3>\n<p>An in-language engine is a policy engine implemented directly within the application&#39;s programming language. Instead of using a separate DSL, policies are expressed using the language&#39;s native constructs, such as functions, classes, and conditionals.</p>\n<h4>Example</h4>\n<pre><code class=\"hljs language-javascript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">canEdit</span>(<span class=\"hljs-params\">user, resource</span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    user.<span class=\"hljs-property\">role</span> === <span class=\"hljs-string\">&quot;admin&quot;</span> ||\n    (user.<span class=\"hljs-property\">role</span> === <span class=\"hljs-string\">&quot;editor&quot;</span> &amp;&amp; resource.<span class=\"hljs-property\">department</span> === user.<span class=\"hljs-property\">department</span>)\n  )\n}\n</code></pre><h2>Goals of a Permission System</h2>\n<p>Before diving into the code, it&#39;s important to understand what a well-designed permission system should look like:</p>\n<ul>\n<li><p><strong>Impossible to access unauthorized data</strong>: This means all data access should go through auth checks before any data is returned or modified.</p>\n</li>\n<li><p><strong>Single source of truth</strong>: Permission logic should be centralized in one place, not scattered throughout your codebase. This makes it easier to audit, update, and reason about.</p>\n</li>\n<li><p><strong>Automatic enforcement</strong>: Authorization should be automatically applied whenever data is accessed or mutated. Developers shouldn&#39;t need to remember to add permission checks manually. They should happen by default.</p>\n</li>\n<li><p><strong>Consistent across frontend and backend</strong>: The same permission rules should produce the same results whether evaluated on the client or server. This prevents confusing UX where buttons appear enabled but actions fail.</p>\n</li>\n<li><p><strong>Never trust the client</strong>: All permission checks must be enforced on the server. Client-side checks are only for UX (hiding buttons, disabling fields) and never for actual security.</p>\n</li>\n<li><p><strong>Fail closed</strong>: When in doubt, deny access. If something goes wrong or a check is missing, the default should be to block access rather than allow it.</p>\n</li>\n</ul>\n<h2>Key Takeaways</h2>\n<ul>\n<li><strong>RBAC</strong> is simple but limited — great for basic apps with clear roles</li>\n<li><strong>ABAC</strong> is flexible but complex — needed for dynamic, attribute-based rules</li>\n<li><strong>ReBAC</strong> models relationships — ideal for collaborative/social features</li>\n<li>Most real apps end up with a <strong>hybrid</strong> approach</li>\n</ul>\n<p>Next, let&#39;s get the workshop project set up on your machine.</p>\n","markdown":"\n# Overview of Permission Systems\n\nThere are three main approaches to implementing authorization, each with different trade-offs between simplicity and flexibility.\n\n![Permission Systems Comparison](/fem-permission-systems-that-scale/images/01-introduction/permission-systems-comparison.svg)\n\n## Role-Based Access Control (RBAC)\n\n**RBAC** assigns permissions based on a user's role. It's the most common and simplest approach.\n\n### How It Works\n\n1. Define **roles** (admin, editor, viewer)\n2. Assign **permissions** to each role (can create, can edit, can delete)\n3. Assign **roles** to users\n4. Check: \"Does this user's role have this permission?\"\n\n### Example\n\n| Role   | View | Create | Edit | Delete |\n| ------ | ---- | ------ | ---- | ------ |\n| Viewer | ✅   | ❌     | ❌   | ❌     |\n| Editor | ✅   | ❌     | ✅   | ❌     |\n| Author | ✅   | ✅     | ✅   | ❌     |\n| Admin  | ✅   | ✅     | ✅   | ✅     |\n\n### Best For\n\n- Applications with clear, hierarchical user types\n- When permissions don't depend on the specific resource\n- Simple permission requirements that change infrequently\n\n### Limitations\n\n- Can't express \"editors can only edit documents in their department\"\n- Role explosion when you need fine-grained control\n- Difficult to handle resource-specific permissions\n\n## Attribute-Based Access Control (ABAC)\n\n**ABAC** makes decisions based on attributes of the user, resource, and environment.\n\n### How It Works\n\n1. Define **attributes** on users (department, role, clearance level)\n2. Define **attributes** on resources (status, owner, department)\n3. Write **policies** that combine attributes with logic\n4. Check: \"Do the attributes satisfy this policy?\"\n\n### Example Policy\n\n```text\nALLOW edit document IF:\n  - user.role IN [editor, author, admin]\n  - AND document.status != \"archived\"\n  - AND (document.department == user.department OR user.role == \"admin\")\n  - AND document.isLocked == false\n```\n\n### Best For\n\n- Complex, dynamic permission requirements\n- Multi-tenant applications\n- When permissions depend on resource properties\n- Fine-grained, field-level access control\n\n### Limitations\n\n- More complex to implement and understand\n- Policies can become hard to audit\n- Performance considerations with many attribute checks\n\n## Relationship-Based Access Control (ReBAC)\n\n**ReBAC** determines access based on the relationships between users and resources.\n\n### How It Works\n\n1. Define **relationship types** (owner, member, viewer)\n2. Create **relationships** between users and resources\n3. Define **permission rules** based on relationships\n4. Check: \"Does this user have a relationship that grants this permission?\"\n\n### Example\n\n```text\nUser \"alice\" --[owner]--> Project \"docs\"\nProject \"docs\" --[contains]--> Document \"readme\"\n\nRule: owner of project can edit documents in that project\nResult: Alice can edit \"readme\"\n```\n\n### Best For\n\n- Social applications (who can see whose posts?)\n- Collaborative tools (shared folders, team workspaces)\n- When permissions flow through object hierarchies\n- Google Drive-style sharing models\n\n### Limitations\n\n- Requires a relationship graph (often a separate database)\n- Can be overkill for simpler permission models\n- More infrastructure complexity\n\n## Policy Engines\n\nEvery authorization needs a policy engine that takes in all the parameters of the access request (user, resource, action, context) and evaluates them against the defined policies to make an allow/deny decision. These engines usually take one of two forms.\n\n### Domain Specific Language (DSL)\n\nA domain-specific language is a specialized language designed to express authorization policies. It allows you to write rules in a concise, human-readable format that the policy engine can interpret.\n\n#### Example\n\n```text\nallow(user, action, resource) if\n  user.role == \"admin\" or\n  (user.role == \"editor\" and resource.department == user.department)\n```\n\n### In-Language Engine\n\nAn in-language engine is a policy engine implemented directly within the application's programming language. Instead of using a separate DSL, policies are expressed using the language's native constructs, such as functions, classes, and conditionals.\n\n#### Example\n\n```javascript\nfunction canEdit(user, resource) {\n  return (\n    user.role === \"admin\" ||\n    (user.role === \"editor\" && resource.department === user.department)\n  )\n}\n```\n\n## Goals of a Permission System\n\nBefore diving into the code, it's important to understand what a well-designed permission system should look like:\n\n- **Impossible to access unauthorized data**: This means all data access should go through auth checks before any data is returned or modified.\n\n- **Single source of truth**: Permission logic should be centralized in one place, not scattered throughout your codebase. This makes it easier to audit, update, and reason about.\n\n- **Automatic enforcement**: Authorization should be automatically applied whenever data is accessed or mutated. Developers shouldn't need to remember to add permission checks manually. They should happen by default.\n\n- **Consistent across frontend and backend**: The same permission rules should produce the same results whether evaluated on the client or server. This prevents confusing UX where buttons appear enabled but actions fail.\n\n- **Never trust the client**: All permission checks must be enforced on the server. Client-side checks are only for UX (hiding buttons, disabling fields) and never for actual security.\n\n- **Fail closed**: When in doubt, deny access. If something goes wrong or a check is missing, the default should be to block access rather than allow it.\n\n## Key Takeaways\n\n- **RBAC** is simple but limited — great for basic apps with clear roles\n- **ABAC** is flexible but complex — needed for dynamic, attribute-based rules\n- **ReBAC** models relationships — ideal for collaborative/social features\n- Most real apps end up with a **hybrid** approach\n\nNext, let's get the workshop project set up on your machine.\n","slug":"overview-of-permission-systems","title":"Overview of Permission Systems","section":"Introduction","icon":"book-open","filePath":"/home/runner/work/fem-permission-systems-that-scale/fem-permission-systems-that-scale/lessons/01-introduction/C-overview-of-permission-systems.md","nextSlug":"/fem-permission-systems-that-scale/lessons/introduction/getting-started","prevSlug":"/fem-permission-systems-that-scale/lessons/introduction/authentication-vs-authorization"}},"__N_SSG":true}