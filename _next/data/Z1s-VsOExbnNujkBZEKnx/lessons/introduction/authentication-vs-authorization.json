{"pageProps":{"post":{"attributes":{"title":"Authentication vs Authorization","description":"Understanding the critical difference between authentication (who are you?) and authorization (what can you do?), and why authorization is often the harder problem."},"html":"<h1>Authentication vs Authorization</h1>\n<p>Before diving into permission systems, we need to clearly understand two concepts that are often confused: <strong>authentication</strong> and <strong>authorization</strong>.</p>\n<h2>The Key Distinction</h2>\n<table>\n<thead>\n<tr>\n<th>Concept</th>\n<th>Question It Answers</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Authentication</strong></td>\n<td>&quot;Who are you?&quot;</td>\n<td>Logging in with email/password</td>\n</tr>\n<tr>\n<td><strong>Authorization</strong></td>\n<td>&quot;What can you do?&quot;</td>\n<td>Can this user delete this document?</td>\n</tr>\n</tbody></table>\n<p>Think of it like entering a secure building:</p>\n<ul>\n<li><strong>Authentication</strong> is showing your ID badge at the entrance — proving you are who you claim to be</li>\n<li><strong>Authorization</strong> is the access levels on your badge — determining which floors and rooms you can enter</li>\n</ul>\n<h2>Authentication Is (Mostly) Solved</h2>\n<p>Authentication has well-established patterns and battle-tested solutions:</p>\n<ul>\n<li><strong>OAuth/OIDC</strong> providers (Google, GitHub, etc.)</li>\n<li><strong>Managed services</strong> (Auth0, Clerk, Firebase Auth)</li>\n<li><strong>Session management</strong> libraries</li>\n<li><strong>JWT</strong> standards</li>\n</ul>\n<p>For most applications, you can integrate an authentication provider and move on. The hard problems — password hashing, session security, MFA — are handled for you.</p>\n<h2>Authorization Is Where Complexity Lives</h2>\n<p>Authorization is a fundamentally different challenge because:</p>\n<h3>1. It&#39;s Deeply Tied to Business Logic</h3>\n<p>Every application has unique rules:</p>\n<ul>\n<li>&quot;Editors can modify documents, but only in their department&quot;</li>\n<li>&quot;Authors can publish their own drafts, but need approval for others&quot;</li>\n<li>&quot;Admins can do everything, except delete locked documents&quot;</li>\n</ul>\n<p>These rules can&#39;t be outsourced to a generic provider — they&#39;re specific to <em>your</em> application.</p>\n<h3>2. It Touches Every Part of Your Codebase</h3>\n<p>Permission checks appear everywhere:</p>\n<ul>\n<li><strong>API routes</strong> — Can this user call this endpoint?</li>\n<li><strong>Database queries</strong> — Which records should be returned?</li>\n<li><strong>UI components</strong> — Should this button be visible?</li>\n<li><strong>Business logic</strong> — Is this state transition allowed?</li>\n</ul>\n<h3>3. It Evolves Constantly</h3>\n<p>Business requirements change:</p>\n<ul>\n<li>&quot;We need to add a new role for external contractors&quot;</li>\n<li>&quot;Documents should be locked after 30 days&quot;</li>\n<li>&quot;Department heads can now approve cross-department access&quot;</li>\n</ul>\n<p>A rigid permission system becomes a bottleneck for feature development.</p>\n<h2>The Cost of Getting It Wrong</h2>\n<p>Poor authorization leads to real problems:</p>\n<table>\n<thead>\n<tr>\n<th>Issue</th>\n<th>Consequence</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Over-permissive</strong></td>\n<td>Data breaches, unauthorized actions, compliance violations</td>\n</tr>\n<tr>\n<td><strong>Under-permissive</strong></td>\n<td>Frustrated users, support tickets, lost productivity</td>\n</tr>\n<tr>\n<td><strong>Inconsistent</strong></td>\n<td>Security holes where checks are missing, confusing UX</td>\n</tr>\n<tr>\n<td><strong>Unmaintainable</strong></td>\n<td>New features require touching dozens of files, bugs multiply</td>\n</tr>\n</tbody></table>\n<h2>This Workshop&#39;s Focus</h2>\n<p>This workshop is <strong>100% about authorization</strong>. We assume you already have authentication handled — users can log in and you know who they are.</p>\n<p>Our challenge is: given a known user, how do we efficiently and maintainably determine what they&#39;re allowed to do?</p>\n<h2>Key Takeaways</h2>\n<ul>\n<li><strong>Authentication</strong> verifies identity; <strong>authorization</strong> controls access</li>\n<li>Authentication is largely a solved problem with good tooling</li>\n<li>Authorization is application-specific and requires careful design</li>\n<li>Poor authorization creates both security risks and maintenance nightmares</li>\n</ul>\n<p>Next, let&#39;s preview the different authorization systems we&#39;ll explore in this workshop.</p>\n","markdown":"\n# Authentication vs Authorization\n\nBefore diving into permission systems, we need to clearly understand two concepts that are often confused: **authentication** and **authorization**.\n\n## The Key Distinction\n\n| Concept            | Question It Answers | Example                             |\n| ------------------ | ------------------- | ----------------------------------- |\n| **Authentication** | \"Who are you?\"      | Logging in with email/password      |\n| **Authorization**  | \"What can you do?\"  | Can this user delete this document? |\n\nThink of it like entering a secure building:\n\n- **Authentication** is showing your ID badge at the entrance — proving you are who you claim to be\n- **Authorization** is the access levels on your badge — determining which floors and rooms you can enter\n\n## Authentication Is (Mostly) Solved\n\nAuthentication has well-established patterns and battle-tested solutions:\n\n- **OAuth/OIDC** providers (Google, GitHub, etc.)\n- **Managed services** (Auth0, Clerk, Firebase Auth)\n- **Session management** libraries\n- **JWT** standards\n\nFor most applications, you can integrate an authentication provider and move on. The hard problems — password hashing, session security, MFA — are handled for you.\n\n## Authorization Is Where Complexity Lives\n\nAuthorization is a fundamentally different challenge because:\n\n### 1. It's Deeply Tied to Business Logic\n\nEvery application has unique rules:\n\n- \"Editors can modify documents, but only in their department\"\n- \"Authors can publish their own drafts, but need approval for others\"\n- \"Admins can do everything, except delete locked documents\"\n\nThese rules can't be outsourced to a generic provider — they're specific to _your_ application.\n\n### 2. It Touches Every Part of Your Codebase\n\nPermission checks appear everywhere:\n\n- **API routes** — Can this user call this endpoint?\n- **Database queries** — Which records should be returned?\n- **UI components** — Should this button be visible?\n- **Business logic** — Is this state transition allowed?\n\n### 3. It Evolves Constantly\n\nBusiness requirements change:\n\n- \"We need to add a new role for external contractors\"\n- \"Documents should be locked after 30 days\"\n- \"Department heads can now approve cross-department access\"\n\nA rigid permission system becomes a bottleneck for feature development.\n\n## The Cost of Getting It Wrong\n\nPoor authorization leads to real problems:\n\n| Issue                | Consequence                                                  |\n| -------------------- | ------------------------------------------------------------ |\n| **Over-permissive**  | Data breaches, unauthorized actions, compliance violations   |\n| **Under-permissive** | Frustrated users, support tickets, lost productivity         |\n| **Inconsistent**     | Security holes where checks are missing, confusing UX        |\n| **Unmaintainable**   | New features require touching dozens of files, bugs multiply |\n\n## This Workshop's Focus\n\nThis workshop is **100% about authorization**. We assume you already have authentication handled — users can log in and you know who they are.\n\nOur challenge is: given a known user, how do we efficiently and maintainably determine what they're allowed to do?\n\n## Key Takeaways\n\n- **Authentication** verifies identity; **authorization** controls access\n- Authentication is largely a solved problem with good tooling\n- Authorization is application-specific and requires careful design\n- Poor authorization creates both security risks and maintenance nightmares\n\nNext, let's preview the different authorization systems we'll explore in this workshop.\n","slug":"authentication-vs-authorization","title":"Authentication vs Authorization","section":"Introduction","icon":"book-open","filePath":"/home/runner/work/fem-permission-systems-that-scale/fem-permission-systems-that-scale/lessons/01-introduction/B-authentication-vs-authorization.md","nextSlug":"/fem-permission-systems-that-scale/lessons/introduction/overview-of-permission-systems","prevSlug":"/fem-permission-systems-that-scale/lessons/introduction/welcome"}},"__N_SSG":true}