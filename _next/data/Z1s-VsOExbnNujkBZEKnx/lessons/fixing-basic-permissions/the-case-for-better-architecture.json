{"pageProps":{"post":{"attributes":{"title":"The Case for Better Architecture"},"html":"<p>Now that we&#39;ve fixed the immediate security issues, let&#39;s reflect on what we&#39;ve done—and why it&#39;s still not good enough.</p>\n<h2>What We Fixed</h2>\n<p>✅ Pages now check permissions on the server<br>✅ Users can&#39;t access resources by guessing URLs<br>✅ Server actions validate permissions before executing<br>✅ UI and server permissions are aligned</p>\n<h2>What&#39;s Still Wrong</h2>\n<p>Despite our fixes, the codebase has fundamental problems that will only get worse as the application grows.</p>\n<h3>1. Duplication Everywhere</h3>\n<p>Count how many times this exact pattern appears:</p>\n<pre><code class=\"hljs language-typescript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">if</span> (\n  user.<span class=\"hljs-property\">role</span> !== <span class=\"hljs-string\">&quot;admin&quot;</span> &amp;&amp;\n  project.<span class=\"hljs-property\">department</span> != <span class=\"hljs-literal\">null</span> &amp;&amp;\n  user.<span class=\"hljs-property\">department</span> !== project.<span class=\"hljs-property\">department</span>\n) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">&quot;/&quot;</span>)\n}\n</code></pre><p>If we add a new department rule (e.g., &quot;managers can access any department&quot;), we need to find and update <strong>every occurrence</strong>. Miss one? Security vulnerability.</p>\n<h3>2. No Single Source of Truth</h3>\n<p>Where do you go to understand &quot;who can create a document&quot;? There&#39;s no clear answer:</p>\n<ul>\n<li>The page component has a check</li>\n<li>The server action has a check</li>\n<li>The UI conditionally renders buttons</li>\n<li>The data access layer has a check</li>\n</ul>\n<p>Each place has its own version of the &quot;truth.&quot; Which one is authoritative?</p>\n<h3>3. Hard to Read Permission Logic</h3>\n<p>Quick—what does this check actually mean?</p>\n<pre><code class=\"hljs language-typescript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">if</span> (user.<span class=\"hljs-property\">role</span> !== <span class=\"hljs-string\">&quot;author&quot;</span> &amp;&amp; user.<span class=\"hljs-property\">role</span> !== <span class=\"hljs-string\">&quot;admin&quot;</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">`/projects/<span class=\"hljs-subst\">${projectId}</span>`</span>)\n}\n</code></pre><p>Compare that to:</p>\n<pre><code class=\"hljs language-typescript\"><button class=\"copy-btn\">Copy</button><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title function_\">canCreateDocument</span>(user)) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-string\">`/projects/<span class=\"hljs-subst\">${projectId}</span>`</span>)\n}\n</code></pre><p>The second version is self-documenting. The first requires mental parsing.</p>\n<h3>4. Adding New Permissions is Painful</h3>\n<p>Imagine we need to add a new rule: &quot;Documents can be marked as &#39;confidential&#39; and only the creator can edit them.&quot;</p>\n<p>With the current architecture, we&#39;d need to:</p>\n<ol>\n<li>Update every edit page</li>\n<li>Update every edit action</li>\n<li>Update the mutation layer</li>\n<li>Update all the UI conditionals</li>\n<li>Hope we didn&#39;t miss anything</li>\n</ol>\n<h2>Key Takeaways</h2>\n<p>Before moving on, remember these principles:</p>\n<ol>\n<li><strong>Always check on the server</strong> - Client-side checks are for UX, not security</li>\n<li><strong>Centralize permission logic</strong> - One place to define, one place to update</li>\n<li><strong>Use descriptive functions</strong> - <code>canEditDocument(user, doc)</code> beats inline conditionals</li>\n<li><strong>Plan for change</strong> - Permission rules will evolve; make that evolution painless</li>\n</ol>\n<h2>What&#39;s Next</h2>\n<p>In the next section, we&#39;ll implement <strong>Role-Based Access Control (RBAC)</strong>. We&#39;ll create a permissions layer that:</p>\n<ul>\n<li>Defines all permissions in one place</li>\n<li>Uses role hierarchy to simplify checks</li>\n<li>Provides helper functions for readable code</li>\n<li>Makes adding new permissions straightforward</li>\n</ul>\n<p>The scattered checks we wrote in this section? They&#39;ll all be replaced with clean, centralized logic.</p>\n","markdown":"\nNow that we've fixed the immediate security issues, let's reflect on what we've done—and why it's still not good enough.\n\n## What We Fixed\n\n✅ Pages now check permissions on the server  \n✅ Users can't access resources by guessing URLs  \n✅ Server actions validate permissions before executing  \n✅ UI and server permissions are aligned\n\n## What's Still Wrong\n\nDespite our fixes, the codebase has fundamental problems that will only get worse as the application grows.\n\n### 1. Duplication Everywhere\n\nCount how many times this exact pattern appears:\n\n```typescript\nif (\n  user.role !== \"admin\" &&\n  project.department != null &&\n  user.department !== project.department\n) {\n  return redirect(\"/\")\n}\n```\n\nIf we add a new department rule (e.g., \"managers can access any department\"), we need to find and update **every occurrence**. Miss one? Security vulnerability.\n\n### 2. No Single Source of Truth\n\nWhere do you go to understand \"who can create a document\"? There's no clear answer:\n\n- The page component has a check\n- The server action has a check\n- The UI conditionally renders buttons\n- The data access layer has a check\n\nEach place has its own version of the \"truth.\" Which one is authoritative?\n\n### 3. Hard to Read Permission Logic\n\nQuick—what does this check actually mean?\n\n```typescript\nif (user.role !== \"author\" && user.role !== \"admin\") {\n  return redirect(`/projects/${projectId}`)\n}\n```\n\nCompare that to:\n\n```typescript\nif (!canCreateDocument(user)) {\n  return redirect(`/projects/${projectId}`)\n}\n```\n\nThe second version is self-documenting. The first requires mental parsing.\n\n### 4. Adding New Permissions is Painful\n\nImagine we need to add a new rule: \"Documents can be marked as 'confidential' and only the creator can edit them.\"\n\nWith the current architecture, we'd need to:\n\n1. Update every edit page\n2. Update every edit action\n3. Update the mutation layer\n4. Update all the UI conditionals\n5. Hope we didn't miss anything\n\n## Key Takeaways\n\nBefore moving on, remember these principles:\n\n1. **Always check on the server** - Client-side checks are for UX, not security\n2. **Centralize permission logic** - One place to define, one place to update\n3. **Use descriptive functions** - `canEditDocument(user, doc)` beats inline conditionals\n4. **Plan for change** - Permission rules will evolve; make that evolution painless\n\n## What's Next\n\nIn the next section, we'll implement **Role-Based Access Control (RBAC)**. We'll create a permissions layer that:\n\n- Defines all permissions in one place\n- Uses role hierarchy to simplify checks\n- Provides helper functions for readable code\n- Makes adding new permissions straightforward\n\nThe scattered checks we wrote in this section? They'll all be replaced with clean, centralized logic.\n","slug":"the-case-for-better-architecture","title":"The Case for Better Architecture","section":"Fixing Basic Permissions","icon":"wrench","filePath":"/home/runner/work/fem-permission-systems-that-scale/fem-permission-systems-that-scale/lessons/02-fixing-basic-permissions/C-the-case-for-better-architecture.md","nextSlug":"/fem-permission-systems-that-scale/lessons/rbac/what-is-rbac","prevSlug":"/fem-permission-systems-that-scale/lessons/fixing-basic-permissions/fixing-basic-permissions"}},"__N_SSG":true}